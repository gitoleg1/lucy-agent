from __future__ import annotations
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import AsyncIterator, Dict, Any, Optional
import asyncio, json, time, re, datetime as dt
from sse_starlette.sse import EventSourceResponse  # נשאר עם sse_starlette כי כך האפליקציה בנויה

router = APIRouter(prefix="/stream", tags=["stream"])

# === EventBus מינימלי (ניתן להחליף בבוס הפנימי שלך) ===
_event_queues: Dict[str, "asyncio.Queue[Dict[str, Any]]"] = {}
def get_queue(task_id: str) -> "asyncio.Queue[Dict[str, Any]]":
    q = _event_queues.get(task_id)
    if q is None:
        q = asyncio.Queue()
        _event_queues[task_id] = q
    return q

async def publish_update(task_id: str, payload: Dict[str, Any] | str) -> None:
    await get_queue(task_id).put({"type": "update", "data": payload, "ts": time.time()})

async def publish_done(task_id: str, payload: Dict[str, Any] | str) -> None:
    await get_queue(task_id).put({"type": "done", "data": payload, "ts": time.time()})

# === מודלים ===
class TaskEvent(BaseModel):
    type: str  # "heartbeat" | "update" | "done"
    data: Optional[Dict[str, Any] | str] = None
    ts: float

# === עזרי זמן/פורמט ===
def now_iso() -> str:
    return dt.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

# sse_starlette מקבלת מהגנרטור "מילונים" עם שדות event+data.
def sse_dict(event: str, data: Dict[str, Any] | None) -> Dict[str, Any]:
    return {"event": event, "data": json.dumps(data or {}, ensure_ascii=False, separators=(",", ":"))}

# === נירמול נתונים מה-runner (גם אם הגיעו כמחרוזת repr) ===
_STATUS_TERMINAL = {"SUCCEEDED", "FAILED", "CANCELLED"}
_RE_STATUS = re.compile(r"status(?:=|:)\s*<[^>]*:\s*'([A-Z]+)'>|status(?:=|:)\s*'([A-Z]+)'", re.IGNORECASE)

def normalize_update_payload(task_id: str, raw: Any) -> Dict[str, Any]:
    base: Dict[str, Any] = {"task_id": task_id, "ts": now_iso()}
    if isinstance(raw, dict):
        base["data"] = raw
        return base
    s = str(raw)
    m = _RE_STATUS.search(s)
    status = (m.group(1) or m.group(2)) if m else None
    base["data"] = {"raw": s}
    if status:
        base["data"]["status"] = status.upper()
    return base

def payload_is_terminal(data: Dict[str, Any]) -> bool:
    status = None
    if isinstance(data, dict):
        inner = data.get("data") if "data" in data else data
        if isinstance(inner, dict):
            status = inner.get("status") or inner.get("Status") or inner.get("STATE")
    if isinstance(status, str):
        return status.upper() in _STATUS_TERMINAL
    return False

async def _event_stream(task_id: str) -> AsyncIterator[Dict[str, Any]]:
    queue = get_queue(task_id)
    heartbeat_interval = 15.0
    last_heartbeat = 0.0

    try:
        # heartbeat ראשון כדי לאשר חיבור
        yield sse_dict("heartbeat", {"task_id": task_id, "ts": now_iso()})
        last_heartbeat = time.time()

        while True:
            timeout = max(0.0, heartbeat_interval - (time.time() - last_heartbeat))
            try:
                evt = await asyncio.wait_for(queue.get(), timeout=timeout)
                evt_obj = TaskEvent(type=evt["type"], data=evt.get("data"), ts=evt["ts"])

                if evt_obj.type == "update":
                    norm = normalize_update_payload(task_id, evt_obj.data)
                    yield sse_dict("update", norm)
                    if payload_is_terminal(norm):
                        # done סינתטי
                        yield sse_dict("done", {"task_id": task_id, "ts": now_iso(), "data": norm.get("data", {})})
                        break

                elif evt_obj.type == "done":
                    norm = {"task_id": task_id, "ts": now_iso(),
                            "data": evt_obj.data if isinstance(evt_obj.data, dict) else {"raw": str(evt_obj.data)}}
                    yield sse_dict("done", norm)
                    break

                else:
                    norm = {"task_id": task_id, "ts": now_iso(), "data": {"raw": evt_obj.data, "note": "unknown_event_type"}}
                    yield sse_dict("update", norm)

            except asyncio.TimeoutError:
                yield sse_dict("heartbeat", {"task_id": task_id, "ts": now_iso()})
                last_heartbeat = time.time()
                continue

    except asyncio.CancelledError:
        return
    except Exception:
        return

@router.get("/tasks/{task_id}")
async def stream_task_events(request: Request, task_id: str):
    if not task_id:
        raise HTTPException(status_code=400, detail="task_id is required")

    async def gen():
        async for item in _event_stream(task_id):
            # עצירה אלגנטית אם הלקוח נסגר
            if await request.is_disconnected():
                break
            yield item

    # נשארים עם EventSourceResponse כדי להתיישר עם שאר הקוד שלך
    return EventSourceResponse(
        gen(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache, no-transform",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",
        },
    )
