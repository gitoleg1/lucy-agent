from __future__ import annotations
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from typing import AsyncIterator, Dict, Any, Optional
import asyncio, json, time, re, datetime as dt, contextlib
from sse_starlette.sse import EventSourceResponse
import httpx

router = APIRouter(prefix="/stream", tags=["stream"])

# === EventBus מינימלי (אפשר להחליף בבוס הפנימי שלך) ===
_event_queues: Dict[str, "asyncio.Queue[Dict[str, Any]]"] = {}
def get_queue(task_id: str) -> "asyncio.Queue[Dict[str, Any]]":
    q = _event_queues.get(task_id)
    if q is None:
        q = asyncio.Queue()
        _event_queues[task_id] = q
    return q

async def publish_update(task_id: str, payload: Dict[str, Any] | str) -> None:
    await get_queue(task_id).put({"type": "update", "data": payload, "ts": time.time()})

async def publish_done(task_id: str, payload: Dict[str, Any] | str) -> None:
    await get_queue(task_id).put({"type": "done", "data": payload, "ts": time.time()})

# === מודלים ===
class TaskEvent(BaseModel):
    type: str  # "heartbeat" | "update" | "done"
    data: Optional[Dict[str, Any] | str] = None
    ts: float

# === עזרי זמן/פורמט ===
def now_iso() -> str:
    return dt.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

def sse_dict(event: str, data: Dict[str, Any] | None) -> Dict[str, Any]:
    return {"event": event, "data": json.dumps(data or {}, ensure_ascii=False, separators=(",", ":"))}

# === נירמול update גם אם הגיע כמחרוזת repr ===
_STATUS_TERMINAL = {"SUCCEEDED", "FAILED", "CANCELLED"}
_RE_STATUS = re.compile(r"status(?:=|:)\s*<[^>]*:\s*'([A-Z]+)'>|status(?:=|:)\s*'([A-Z]+)'", re.IGNORECASE)

def normalize_update_payload(task_id: str, raw: Any) -> Dict[str, Any]:
    base: Dict[str, Any] = {"task_id": task_id, "ts": now_iso()}
    if isinstance(raw, dict):
        base["data"] = raw
        return base
    s = str(raw)
    m = _RE_STATUS.search(s)
    status = (m.group(1) or m.group(2)) if m else None
    base["data"] = {"raw": s}
    if status:
        base["data"]["status"] = status.upper()
    return base

def payload_is_terminal(data: Dict[str, Any]) -> bool:
    status = None
    if isinstance(data, dict):
        inner = data.get("data") if "data" in data else data
        if isinstance(inner, dict):
            status = inner.get("status") or inner.get("Status") or inner.get("STATE")
    if isinstance(status, str):
        return status.upper() in _STATUS_TERMINAL
    return False

# === Fallback Poller: פולינג ל-GET /tasks/{id} ➝ update/done ===
async def _poll_task_until_done(task_id: str, api_key: Optional[str]) -> None:
    base_url = "http://127.0.0.1:8000"
    headers = {"Accept": "application/json"}
    if api_key:
        headers["X-Api-Key"] = api_key

    prev_snapshot: Optional[str] = None
    async with httpx.AsyncClient(timeout=httpx.Timeout(5.0, read=5.0, write=5.0, connect=2.0)) as client:
        while True:
            try:
                resp = await client.get(f"{base_url}/tasks/{task_id}", headers=headers)
                if resp.status_code == 404:
                    await asyncio.sleep(0.5); continue
                resp.raise_for_status()
                data = resp.json()
            except Exception:
                await asyncio.sleep(0.5); continue

            snap = json.dumps(data, sort_keys=True, separators=(",", ":"))
            if snap != prev_snapshot:
                prev_snapshot = snap
                await publish_update(task_id, {"snapshot": data})

            status = str(data.get("status", "")).upper()
            if status in _STATUS_TERMINAL:
                await publish_done(task_id, {"status": status, "result": data})
                return

            await asyncio.sleep(0.5)

async def _event_stream(task_id: str) -> AsyncIterator[Dict[str, Any]]:
    queue = get_queue(task_id)
    heartbeat_interval = 15.0
    last_heartbeat = 0.0

    try:
        yield sse_dict("heartbeat", {"task_id": task_id, "ts": now_iso()})
        last_heartbeat = time.time()

        while True:
            timeout = max(0.0, heartbeat_interval - (time.time() - last_heartbeat))
            try:
                evt = await asyncio.wait_for(queue.get(), timeout=timeout)
                evt_obj = TaskEvent(type=evt["type"], data=evt.get("data"), ts=evt["ts"])

                if evt_obj.type == "update":
                    norm = normalize_update_payload(task_id, evt_obj.data)
                    yield sse_dict("update", norm)
                    if payload_is_terminal(norm):
                        yield sse_dict("done", {"task_id": task_id, "ts": now_iso(), "data": norm.get("data", {})})
                        break

                elif evt_obj.type == "done":
                    norm = {"task_id": task_id, "ts": now_iso(),
                            "data": evt_obj.data if isinstance(evt_obj.data, dict) else {"raw": str(evt_obj.data)}}
                    yield sse_dict("done", norm)
                    break

                else:
                    norm = {"task_id": task_id, "ts": now_iso(), "data": {"raw": evt_obj.data, "note": "unknown_event_type"}}
                    yield sse_dict("update", norm)

            except asyncio.TimeoutError:
                yield sse_dict("heartbeat", {"task_id": task_id, "ts": now_iso()})
                last_heartbeat = time.time()
                continue
    except asyncio.CancelledError:
        return
    except Exception:
        return

@router.get("/tasks/{task_id}")
async def stream_task_events(request: Request, task_id: str):
    if not task_id:
        raise HTTPException(status_code=400, detail="task_id is required")

    # תמיכה גם ב-Header וגם ב-?api_key=
    api_key = request.headers.get("X-Api-Key") or request.query_params.get("api_key")

    poller = asyncio.create_task(_poll_task_until_done(task_id, api_key))

    async def gen():
        try:
            async for item in _event_stream(task_id):
                if await request.is_disconnected():
                    break
                yield item
        finally:
            poller.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await poller

    return EventSourceResponse(
        gen(),
        media_type="text/event-stream",
        headers={"Cache-Control": "no-cache, no-transform",
                 "Connection": "keep-alive",
                 "X-Accel-Buffering": "no"},
    )
