from fastapi import APIRouter
from typing import Any, Dict, List, Union, Optional
import asyncio, asyncssh, time
from loguru import logger

from ..models import ActionRequest, ActionResult
from .logs import log_action

router = APIRouter()

def sh_quote(s: str) -> str:
    if s is None or s == "":
        return "''"
    return "'" + s.replace("'", "'\"'\"'") + "'"

def _normalize_command(
    cmd: Union[str, List[str], None],
    commands: Optional[List[str]] = None,
    workdir: Optional[str] = None,
    env: Optional[Dict[str, str]] = None,
) -> str:
    seq: List[str] = []
    if env:
        exports = " ".join(f"{k}={sh_quote(v)}" for k, v in env.items())
        seq.append(f"export {exports}")
    if workdir:
        seq.append(f"cd {sh_quote(workdir)}")
    if isinstance(cmd, list):
        seq.extend(str(x) for x in cmd if x)
    elif isinstance(cmd, str) and cmd.strip():
        seq.append(cmd.strip())
    if commands:
        seq.extend(str(x) for x in commands if x)
    return " && ".join(seq)

@router.post("/ssh", response_model=ActionResult)
async def run_ssh(req: ActionRequest) -> ActionResult:
    p: Dict[str, Any] = dict(getattr(req, "params", {}) or {})

    if p.get("dry_run"):
        out = _normalize_command(
            p.get("command"),
            commands=p.get("commands"),
            workdir=p.get("workdir"),
            env=p.get("env"),
        )
        if out and not out.endswith("\n"):
            out += "\n"
        return ActionResult(status=True, output=out)

    host: str = p.get("host", "127.0.0.1")
    port: int = int(p.get("port", 22))
    username: Optional[str] = p.get("username")
    password: Optional[str] = p.get("password")
    private_key_path: Optional[str] = p.get("private_key_path")
    timeout: float = float(p.get("timeout", 30.0))

    cmd = _normalize_command(
        p.get("command"),
        commands=p.get("commands"),
        workdir=p.get("workdir"),
        env=p.get("env"),
    )

    try:
        client_keys = None
        if private_key_path:
            client_keys = [asyncssh.read_private_key(private_key_path)]

        async with asyncssh.connect(
            host, port=port, username=username,
            password=password, client_keys=client_keys
        ) as conn:
            result = await asyncio.wait_for(conn.run(cmd, check=False), timeout=timeout)
            ok = (result.exit_status == 0)
            out = result.stdout or result.stderr or ""
            if not out.endswith("\n"):
                out += "\n"
            return ActionResult(status=ok, output=out)
    except asyncio.TimeoutError:
        return ActionResult(status=False, output="", error=f"TimeoutError: command exceeded {timeout:.1f}s")
    except Exception as e:
        return ActionResult(status=False, output="", error=f"{type(e).__name__}: {e}")
