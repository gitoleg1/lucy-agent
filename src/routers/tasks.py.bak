from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional, Literal, Dict, Any
from uuid import uuid4
import json

from sqlalchemy import select
from sqlalchemy.exc import SQLAlchemyError

from ..db.session import get_session
from ..models.tasks import (
    Task, Action, Run, Approval, AuditLog,
    TaskStatus, RunStatus, ActionType, now_iso
)
from ..services.runner import run_shell_command
from ..services.audit import write_audit

router = APIRouter(prefix="/tasks", tags=["tasks"])

# ---------- Schemas ----------
class ActionIn(BaseModel):
    type: Literal["shell","http","ssh","gads","waha","browser","file_ops"] = "shell"
    params: Dict[str, Any] = Field(default_factory=dict)

class TaskCreate(BaseModel):
    title: str
    description: Optional[str] = None
    require_approval: bool = False
    actions: List[ActionIn] = Field(default_factory=list)

class ApprovalOut(BaseModel):
    id: str
    task_id: str
    token: str
    decision: Optional[Literal["APPROVE","REJECT"]] = None
    decided_by: Optional[str] = None
    decided_at: Optional[str] = None
    created_at: str
    expires_at: Optional[str] = None

class RunOut(BaseModel):
    id: str
    action_id: str
    status: str
    started_at: Optional[str]
    ended_at: Optional[str]
    exit_code: Optional[int]
    stdout_path: Optional[str]
    stderr_path: Optional[str]

class TaskOut(BaseModel):
    id: str
    title: str
    description: Optional[str]
    status: str
    require_approval: int
    created_at: str
    updated_at: str
    started_at: Optional[str]
    ended_at: Optional[str]
    approvals: List[ApprovalOut] = Field(default_factory=list)

class ApproveIn(BaseModel):
    token: str
    decision: Literal["APPROVE","REJECT"]
    decided_by: Optional[str] = "telegram:user"

class AuditOut(BaseModel):
    id: str
    task_id: str
    event: str
    data: dict = Field(default_factory=dict)
    created_at: str

# ---------- Helpers ----------
def _serialize_task_with_approvals(task: Task, session) -> TaskOut:
    appr_rows = session.execute(
        select(Approval).where(Approval.task_id == task.id)
    ).scalars().all()
    return TaskOut(
        id=task.id,
        title=task.title,
        description=task.description,
        status=task.status,
        require_approval=1 if task.require_approval else 0,
        created_at=task.created_at,
        updated_at=task.updated_at,
        started_at=task.started_at,
        ended_at=task.ended_at,
        approvals=[
            ApprovalOut(
                id=a.id,
                task_id=a.task_id,
                token=a.token,
                decision=a.decision,
                decided_by=a.decided_by,
                decided_at=a.decided_at,
                created_at=a.created_at,
                expires_at=getattr(a, "expires_at", None),
            )
            for a in appr_rows
        ],
    )

# ---------- Routes ----------
@router.post("/tasks", response_model=TaskOut)
def create_task(payload: TaskCreate):
    try:
        with get_session() as s:
            task = Task(
                id=str(uuid4()),
                title=payload.title,
                description=payload.description,
                status=TaskStatus.WAITING_APPROVAL,
                require_approval=1 if payload.require_approval else 0,
                created_at=now_iso(),
                updated_at=now_iso(),
                started_at=None,
                ended_at=None,
            )
            s.add(task)

            # actions
            for idx, a in enumerate(payload.actions):
                act = Action(
                    id=str(uuid4()),
                    task_id=task.id,
                    idx=idx,
                    type=a.type,
                    params_json=json.dumps(a.params or {}),  # חשוב: JSON string
                    created_at=now_iso(),
                    updated_at=now_iso(),
                )
                s.add(act)

            # approval (single token for now)
            appr = Approval(
                id=str(uuid4()),
                task_id=task.id,
                token=str(uuid4()),
                decision=None,
                decided_by=None,
                decided_at=None,
                created_at=now_iso(),
            )
            s.add(appr)

            # audit
            write_audit(
                s, task_id=task.id, event="task_created",
                data={"title": task.title, "require_approval": bool(task.require_approval), "actions_count": len(payload.actions)},
                message=f"task created ({task.title})",
            )

            s.commit()
            s.refresh(task)
            out = _serialize_task_with_approvals(task, s)
            return out
    except SQLAlchemyError as e:
        return HTTPException(status_code=500, detail=f"DB error: {e}")

@router.get("/tasks/{task_id}", response_model=TaskOut)
def get_task(task_id: str):
    with get_session() as s:
        task = s.get(Task, task_id)
        if not task:
            raise HTTPException(status_code=404, detail="Not Found")
        return _serialize_task_with_approvals(task, s)

@router.post("/tasks/{task_id}/approve", response_model=TaskOut)
def decide_approval(task_id: str, body: ApproveIn):
    with get_session() as s:
        task = s.get(Task, task_id)
        if not task:
            raise HTTPException(status_code=404, detail="Not Found")

        appr = s.execute(
            select(Approval).where(Approval.task_id == task_id)
        ).scalars().first()
        if not appr or appr.token != body.token:
            raise HTTPException(status_code=400, detail="Invalid token")

        appr.decision = body.decision
        appr.decided_by = body.decided_by
        appr.decided_at = now_iso()
        s.add(appr)

        if body.decision == "APPROVE":
            task.status = TaskStatus.APPROVED
        else:
            task.status = TaskStatus.REJECTED
        task.updated_at = now_iso()
        s.add(task)

        write_audit(
            s, task_id=task.id, event="approval_decided",
            data={"decision": body.decision, "by": body.decided_by},
            message=f"approval {body.decision.lower()}",
        )

        s.commit()
        s.refresh(task)
        return _serialize_task_with_approvals(task, s)

@router.post("/tasks/{task_id}/run", response_model=List[RunOut])
def run_task(task_id: str):
    with get_session() as s:
        task = s.get(Task, task_id)
        if not task:
            raise HTTPException(status_code=404, detail="Not Found")
        if task.require_approval and task.status != TaskStatus.APPROVED:
            raise HTTPException(status_code=400, detail="Task not approved")

        actions = s.execute(
            select(Action).where(Action.task_id == task_id).order_by(Action.idx.asc())
        ).scalars().all()
        if not actions:
            return []

        runs_out: List[RunOut] = []

        for act in actions:
            # כרגע תומכים ב-shell בלבד (עוד סוגים יתווספו בהמשך)
            params = json.loads(act.params_json or "{}")
            if act.type == ActionType.SHELL or act.type == "shell":
                run_id = str(uuid4())
                started_at, ended_at, exit_code, stdout_path, stderr_path = run_shell_command(params.get("cmd", ""))

                run = Run(
                    id=run_id,
                    action_id=act.id,
                    status=RunStatus.SUCCEEDED if exit_code == 0 else RunStatus.FAILED,
                    started_at=started_at,
                    ended_at=ended_at,
                    exit_code=exit_code,
                    stdout_path=stdout_path,
                    stderr_path=stderr_path,
                )
                s.add(run)

                write_audit(
                    s, task_id=task.id, action_id=act.id, run_id=run_id,
                    event="action_executed",
                    data={"type": "shell", "cmd": params.get("cmd", ""), "exit_code": exit_code},
                    message="shell executed",
                )

                runs_out.append(
                    RunOut(
                        id=run_id,
                        action_id=act.id,
                        status=run.status,
                        started_at=started_at,
                        ended_at=ended_at,
                        exit_code=exit_code,
                        stdout_path=stdout_path,
                        stderr_path=stderr_path,
                    )
                )
            else:
                # future types
                write_audit(
                    s, task_id=task.id, action_id=act.id,
                    event="action_skipped",
                    data={"type": act.type},
                    message="unsupported action type",
                )

        s.commit()
        return runs_out

@router.get("/tasks/{task_id}/audit", response_model=List[AuditOut])
def get_audit(task_id: str):
    """
    מחזיר את היסטוריית האודיט; תומך בשם עמודה event_type / event / type
    וגם data_json או data.
    """
    with get_session() as s:
        rows = (
            s.execute(
                select(AuditLog)
                .where(AuditLog.task_id == task_id)
                .order_by(AuditLog.created_at.asc())
            )
            .scalars()
            .all()
        )

    out: List[AuditOut] = []
    for r in rows:
        event = (
            getattr(r, "event_type", None)
            or getattr(r, "event", None)
            or getattr(r, "type", None)
            or "event"
        )
        raw = getattr(r, "data_json", None) or getattr(r, "data", None)
        try:
            data = json.loads(raw) if isinstance(raw, str) else (raw or {})
            if not isinstance(data, dict):
                data = {}
        except Exception:
            data = {}

        out.append(
            AuditOut(
                id=r.id,
                task_id=r.task_id,
                event=event,
                data=data,
                created_at=r.created_at,
            )
        )
    return out
