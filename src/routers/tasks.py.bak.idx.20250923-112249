from __future__ import annotations

import json
import os
import subprocess
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional
from uuid import uuid4

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from sqlalchemy import select

from ..db.session import get_session
from ..models.tasks import (
    Task,
    Action,
    Run,
    Approval,
    AuditLog,
    TaskStatus,
    now_iso,
)
from ..services.audit import write_audit


# --- helper to map desired statuses to DB-allowed values ---

# ===== Router =====
router = APIRouter(prefix="/tasks", tags=["tasks"])


# ===== Schemas =====
class ActionIn(BaseModel):
    type: Literal["shell"] = "shell"
    params: Dict[str, Any] = Field(default_factory=dict)


class TaskCreate(BaseModel):
    title: str
    description: Optional[str] = None
    require_approval: bool = False
    actions: List[ActionIn] = Field(default_factory=list)


class ApprovalIn(BaseModel):
    token: str
    decision: Literal["APPROVE", "REJECT"]
    decided_by: str


class RunOut(BaseModel):
    id: str
    task_id: str
    action_id: str
    status: str
    started_at: Optional[str] = None
    ended_at: Optional[str] = None
    stdout_path: Optional[str] = None
    stderr_path: Optional[str] = None
    exit_code: Optional[int] = None


class AuditOut(BaseModel):
    id: str
    task_id: str
    event: str
    data: Dict[str, Any] = Field(default_factory=dict)
    created_at: str


class TaskOut(BaseModel):
    id: str
    title: str
    description: Optional[str]
    status: str
    require_approval: int
    created_at: str
    updated_at: str
    started_at: Optional[str]
    ended_at: Optional[str]
    approvals: List[Dict[str, Any]] = Field(default_factory=list)


# ===== Helpers =====
RUNS_BASE = Path.home() / ".local" / "share" / "lucy-agent" / "runs"
RUNS_BASE.mkdir(parents=True, exist_ok=True)


def _task_to_out(s, task: Task) -> TaskOut:
    approvals: List[Dict[str, Any]] = []
    try:
        aps = s.execute(select(Approval).where(Approval.task_id == task.id)).scalars().all()
        for a in aps:
            approvals.append(
                {
                    "id": a.id,
                    "task_id": a.task_id,
                    "token": a.token,
                    "decision": a.decision,
                    "decided_by": a.decided_by,
                    "decided_at": a.decided_at,
                    "created_at": a.created_at,
                    "expires_at": a.expires_at,
                }
            )
    except Exception:
        approvals = []

    return TaskOut(
        id=task.id,
        title=task.title,
        description=task.description,
        status=task.status,
        require_approval=task.require_approval,
        created_at=task.created_at,
        updated_at=task.updated_at,
        started_at=task.started_at,
        ended_at=task.ended_at,
        approvals=approvals,
    )


# ===== Endpoints =====


@router.post("/", response_model=TaskOut)
def create_task(payload: TaskCreate):
    # מחרוזות סטטוס כדי לא להיות תלויים ב-Enum ספציפי
    status_value = "WAITING_APPROVAL" if payload.require_approval else "PENDING"
    now = now_iso()
    with get_session() as s:
        # Task
        task = Task(
            id=str(uuid4()),
            title=payload.title,
            description=payload.description,
            status=status_value,
            require_approval=1 if payload.require_approval else 0,
            created_at=now,
            updated_at=now,
            started_at=None,
            ended_at=None,
        )
        s.add(task)
        safe_commit(s)

        # Approval (אם נדרש)
        if payload.require_approval:
            ap = Approval(
                id=str(uuid4()),
                task_id=task.id,
                token=str(uuid4()),
                decision=None,
                decided_by=None,
                decided_at=None,
                created_at=now,
                expires_at=None,
            )
            s.add(ap)

        # Actions עם idx (פותר NOT NULL על actions.idx)
        for i, a in enumerate(payload.actions or []):
            params_json = json.dumps(a.params or {})
            act = Action(
                id=str(uuid4()),
                task_id=task.id,
                idx=i,
                type=a.type,
                params_json=params_json,
                created_at=now,
                updated_at=now,
            )
            s.add(act)

        safe_commit(s)

        # Audit
        write_audit(
            s,
            task_id=task.id,
            event="task_created",
            data={
                "title": task.title,
                "require_approval": bool(task.require_approval),
                "actions_count": len(payload.actions or []),
            },
        )

        return _task_to_out(s, task)


@router.get("/{task_id}", response_model=TaskOut)
def get_task(task_id: str):
    with get_session() as s:
        t = s.execute(select(Task).where(Task.id == task_id)).scalars().first()
        if not t:
            raise HTTPException(status_code=404, detail="Task not found")
        return _task_to_out(s, t)


@router.post("/{task_id}/approve", response_model=TaskOut)
def approve_task(task_id: str, body: ApprovalIn):
    with get_session() as s:
        t = s.execute(select(Task).where(Task.id == task_id)).scalars().first()
        if not t:
            raise HTTPException(status_code=404, detail="Task not found")

        ap = s.execute(select(Approval).where(Approval.task_id == task_id)).scalars().first()
        if not ap or ap.token != body.token:
            raise HTTPException(status_code=400, detail="Invalid approval token")

        ap.decision = body.decision
        ap.decided_by = body.decided_by
        ap.decided_at = now_iso()
        t.status = "APPROVED" if body.decision == "APPROVE" else TaskStatus.REJECTED
        t.updated_at = now_iso()

        write_audit(
            s,
            task_id=task_id,
            event="approval_decided",
            data={"decision": body.decision, "by": body.decided_by},
            message="approval decided",
        )

        safe_commit(s)
        return _task_to_out(s, t)


@router.post("/{task_id}/run", response_model=List[RunOut])
def run_task(task_id: str):
    with get_session() as s:
        t = s.execute(select(Task).where(Task.id == task_id)).scalars().first()
        if not t:
            raise HTTPException(status_code=404, detail="Task not found")

        if t.require_approval and t.status != "APPROVED":
            raise HTTPException(status_code=400, detail="Task requires approval")

        acts = s.execute(select(Action).where(Action.task_id == task_id)).scalars().all()
        if not acts:
            raise HTTPException(status_code=400, detail="No actions to run")

        results: List[RunOut] = []

        for a in acts:
            if a.type != "shell":
                raise HTTPException(status_code=400, detail=f"Unsupported action type: {a.type}")

            params = json.loads(a.params_json or "{}")
            cmd = params.get("cmd")
            if not cmd:
                raise HTTPException(status_code=400, detail="shell action missing 'cmd'")

            run_id = str(uuid4())
            run_dir = RUNS_BASE / run_id
            run_dir.mkdir(parents=True, exist_ok=True)
            stdout_p = run_dir / "stdout.log"
            stderr_p = run_dir / "stderr.log"

            r = Run(
                id=run_id,
                action_id=a.id,
                status="RUNNING",
                started_at=now_iso(),
                ended_at=None,
                exit_code=None,
                stdout_path=str(stdout_p),
                stderr_path=str(stderr_p),
            )
            s.add(r)
            safe_commit(s)

            write_audit(
                s,
                task_id=task_id,
                event="action_start",
                data={"action_id": a.id, "type": a.type, "cmd": cmd},
                run_id=run_id,
                action_id=a.id,
                message="action started",
            )

            try:
                with open(stdout_p, "wb") as out, open(stderr_p, "wb") as err:
                    proc = subprocess.run(
                        cmd,
                        shell=True,
                        stdout=out,
                        stderr=err,
                        cwd=os.path.expanduser("~"),
                    )
                exit_code = int(proc.returncode)
                r.exit_code = exit_code
                r.status = "SUCCEEDED" if r.exit_code == 0 else "FAILED"
                r.ended_at = now_iso()
                safe_commit(s)

                write_audit(
                    s,
                    task_id=task_id,
                    event="action_end",
                    data={"action_id": a.id, "exit_code": exit_code},
                    run_id=run_id,
                    action_id=a.id,
                    message="action ended",
                )

            except Exception as e:
                r.status = "FAILED"
                r.ended_at = now_iso()
                r.exit_code = -1
                safe_commit(s)

                write_audit(
                    s,
                    task_id=task_id,
                    event="action_error",
                    data={"action_id": a.id, "error": repr(e)},
                    run_id=run_id,
                    action_id=a.id,
                    message=f"action error: {e!r}",
                )

            results.append(
                RunOut(
                    id=r.id,
                    task_id=task_id,
                    action_id=r.action_id,
                    status=r.status,
                    started_at=r.started_at,
                    ended_at=r.ended_at,
                    stdout_path=r.stdout_path,
                    stderr_path=r.stderr_path,
                    exit_code=r.exit_code,
                )
            )

        t.status = "FAILED" if any(ro.status == "FAILED" for ro in results) else "SUCCEEDED"
        t.updated_at = now_iso()
        safe_commit(s)

        return results


@router.get("/{task_id}/audit", response_model=List[AuditOut])
def get_audit(task_id: str):
    with get_session() as s:
        rows = (
            s.execute(
                select(AuditLog)
                .where(AuditLog.task_id == task_id)
                .order_by(AuditLog.created_at.asc())
            )
            .scalars()
            .all()
        )

        out: List[AuditOut] = []
        for r in rows:
            event = (
                getattr(r, "event_type", None)
                or getattr(r, "event", None)
                or getattr(r, "type", None)
                or "event"
            )
            raw = getattr(r, "data_json", None) or getattr(r, "data", None)
            try:
                data = json.loads(raw) if isinstance(raw, str) else (raw or {})
            except Exception:
                data = {}
            out.append(
                AuditOut(
                    id=r.id,
                    task_id=task_id,
                    event=event,
                    data=data,
                    created_at=r.created_at,
                )
            )
        return out


# --- local commit helper ---
def safe_commit(s) -> None:
    """Commit and roll back on error; small local helper for this router."""
    try:
        s.commit()
    except Exception:
        try:
            s.rollback()
        except Exception:
            pass
        raise
# >>> LUCY_AUTOPILOT_QUICK_RUN_BEGIN
# ========= Lucy Autopilot — QuickRun & Agent Shell (MVP, Dynamic Columns) =========
from typing import List, Optional  # noqa: E402
from pydantic import BaseModel      # noqa: E402
from uuid import uuid4              # noqa: E402
from pathlib import Path            # noqa: E402
import os, subprocess               # noqa: E402
from fastapi import HTTPException   # noqa: E402
from sqlalchemy.inspection import inspect as sa_inspect  # noqa: E402

# --- סכימות לפנים ההנדפוינט ---
class QuickRunIn(BaseModel):
    title: str = "autopilot"
    actions: List[ActionIn]

class QuickRunOut(BaseModel):
    task: TaskOut
    runs: List[RunOut]
    audit: List[AuditOut]

def _model_columns(cls):
    try:
        return {c.key for c in sa_inspect(cls).columns}
    except Exception:
        return set()

def _first_present(cols, candidates):
    for c in candidates:
        if c in cols:
            return c
    return None

@router.post("/quick-run", response_model=QuickRunOut)
def quick_run(payload: QuickRunIn):
    """
    יצירה → ריצה → המתנה → תשובה מאוחדת (MVP: shell בלבד).
    חסין סכימה: יוצר Action/Run עם השדות הקיימים בפועל בלבד.
    """
    from sqlalchemy import select

    # 1) יצירה (ללא אישור)
    t = Task(
        id=str(uuid4()),
        title=payload.title,
        description=None if 'description' in _model_columns(Task) else None,
        status=TaskStatus.PENDING.value if hasattr(TaskStatus, "PENDING") else "PENDING",
        require_approval=False if 'require_approval' in _model_columns(Task) else None,
        created_at=now_iso() if 'created_at' in _model_columns(Task) else None,
        updated_at=now_iso() if 'updated_at' in _model_columns(Task) else None,
    )
    with get_session() as s:
        s.add(t)
        for a in payload.actions:
            # נכין kwargs חוקיים בלבד ל-Action
            a_cols = _model_columns(Action)
            kwargs = {
                "id": str(uuid4()) if "id" in a_cols else None,
                "task_id": t.id if "task_id" in a_cols else None,
                "type": a.type if "type" in a_cols else None,
                "created_at": now_iso() if "created_at" in a_cols else None,
            }
            # נבחר שדה מתאים לשמירת ה-cmd אם קיים
            cmd = (a.params or {}).get("cmd") if getattr(a, "params", None) or isinstance(getattr(a, "params", None), dict) else (a.params.get("cmd") if hasattr(a, "params") else None)
            # במקרה שאין a.params (ActionIn יכול להיות אחר), ננסה מפורשות:
            if cmd is None and isinstance(getattr(a, "params", None), dict):
                cmd = a.params.get("cmd")
            cmd_field = _first_present(a_cols, ["params", "payload", "data", "meta", "details", "command", "cmd", "args", "stdin"])
            if cmd_field and cmd is not None:
                kwargs[cmd_field] = cmd

            # הסרה של None-ים — SQLAlchemy לא אוהב kwargs לא מוכרים/None על שדות לא מוגדרים
            kwargs = {k: v for k, v in kwargs.items() if v is not None}

            act_obj = Action(**kwargs)
            s.add(act_obj)
        safe_commit(s)
        write_audit(s, t.id, "task_created", {"title": t.title, "require_approval": True if 'require_approval' in _model_columns(Task) and getattr(t, 'require_approval', False) else False})

    # 2) ריצה סינכרונית (MVP: shell)
    run_results: List[RunOut] = []
    with get_session() as s:
        t_db = s.scalar(select(Task).where(Task.id == t.id))
        if not t_db:
            raise HTTPException(status_code=404, detail="Task not found")

        acts = s.scalars(select(Action).where(Action.task_id == getattr(t_db, 'id'))).all()
        if not acts:
            if hasattr(t_db, 'status'):
                t_db.status = "SUCCEEDED"
            if hasattr(t_db, 'updated_at'):
                t_db.updated_at = now_iso()
            safe_commit(s)
        else:
            for act in acts:
                r_cols = _model_columns(Run)
                r_kwargs = {
                    "id": str(uuid4()) if "id" in r_cols else None,
                    "task_id": t_db.id if "task_id" in r_cols else None,
                    "action_id": getattr(act, 'id', None) if "action_id" in r_cols else None,
                    "status": "RUNNING" if "status" in r_cols else None,
                    "started_at": now_iso() if "started_at" in r_cols else None,
                }
                r_kwargs = {k: v for k, v in r_kwargs.items() if v is not None}
                r = Run(**r_kwargs)
                s.add(r)
                safe_commit(s)

                # cmd לא ניקח מה-DB (אולי אין שדה כזה), אלא מהaudit: נחלץ דינמית
                a_cols = _model_columns(Action)
                cmd_field = _first_present(a_cols, ["params","payload","data","meta","details","command","cmd","args","stdin"])
                cmd_val = getattr(act, cmd_field) if (cmd_field and hasattr(act, cmd_field)) else None

                write_audit(s, getattr(t_db, 'id'), "action_start", {
                    "action_id": getattr(act, 'id', None),
                    "type": getattr(act, 'type', None),
                    "cmd": cmd_val,
                })

                try:
                    # נריץ רק shell cmd אמיתי
                    if getattr(act, 'type', None) != "shell":
                        raise RuntimeError(f"Unsupported action type: {getattr(act, 'type', None)}")

                    cmd_to_run = cmd_val
                    if not cmd_to_run:
                        raise RuntimeError("Missing shell cmd")

                    run_dir = Path(os.environ.get("LUCY_RUNS_DIR", str(Path.home() / ".local/share/lucy-agent/runs"))) / (getattr(r, 'id', 'run'))
                    run_dir.mkdir(parents=True, exist_ok=True)
                    stdout_path = run_dir / "stdout.log"
                    stderr_path = run_dir / "stderr.log"

                    with open(stdout_path, "wb") as out, open(stderr_path, "wb") as err:
                        proc = subprocess.run(cmd_to_run, shell=True, stdout=out, stderr=err)

                    if hasattr(r, 'stdout_path'): r.stdout_path = str(stdout_path)
                    if hasattr(r, 'stderr_path'): r.stderr_path = str(stderr_path)
                    if hasattr(r, 'exit_code'):   r.exit_code   = int(proc.returncode)
                    if hasattr(r, 'status'):      r.status      = "SUCCEEDED" if int(proc.returncode) == 0 else "FAILED"
                    if hasattr(r, 'ended_at'):    r.ended_at    = now_iso()
                    safe_commit(s)

                    write_audit(s, getattr(t_db, 'id'), "action_end", {
                        "action_id": getattr(act, 'id', None),
                        "exit_code": getattr(r, 'exit_code', None)
                    })

                except Exception as e:
                    if hasattr(r, 'exit_code'): r.exit_code = -1
                    if hasattr(r, 'status'):    r.status = "FAILED"
                    if hasattr(r, 'ended_at'):  r.ended_at = now_iso()
                    safe_commit(s)
                    write_audit(s, getattr(t_db, 'id'), "action_end", {
                        "action_id": getattr(act, 'id', None),
                        "exit_code": getattr(r, 'exit_code', None),
                        "error": str(e),
                    })

                run_results.append(RunOut(
                    id=getattr(r, 'id', None),
                    task_id=getattr(r, 'task_id', None),
                    action_id=getattr(r, 'action_id', None),
                    status=getattr(r, 'status', None),
                    started_at=getattr(r, 'started_at', None),
                    ended_at=getattr(r, 'ended_at', None),
                    stdout_path=getattr(r, 'stdout_path', None),
                    stderr_path=getattr(r, 'stderr_path', None),
                    exit_code=getattr(r, 'exit_code', None),
                ))

            if hasattr(t_db, 'status'):
                t_db.status = "FAILED" if any(getattr(ro, 'status', None) == "FAILED" for ro in run_results) else "SUCCEEDED"
            if hasattr(t_db, 'updated_at'):
                t_db.updated_at = now_iso()
            safe_commit(s)

    # 3) Audit מלא
    with get_session() as s:
        from sqlalchemy import select
        audit_items = s.scalars(
            select(AuditLog).where(AuditLog.task_id == getattr(t, 'id')).order_by(AuditLog.created_at if 'created_at' in _model_columns(AuditLog) else AuditLog.id)
        ).all()
        audit_out = [AuditOut(
            id=getattr(a, 'id', None), task_id=getattr(a, 'task_id', None),
            event=getattr(a, 'event', None), data=getattr(a, 'data', None),
            created_at=getattr(a, 'created_at', None)
        ) for a in audit_items]

    # 4) TaskOut עדכני
    with get_session() as s:
        from sqlalchemy import select
        t_final = s.scalar(select(Task).where(Task.id == getattr(t, 'id')))
        task_out = _task_to_out(s, t_final)

    return QuickRunOut(task=task_out, runs=run_results, audit=audit_out)

# --- Agent Shell facade ---
class AgentShellIn(BaseModel):
    cmd: str
    title: Optional[str] = "agent-shell"

@router.post("/agent/shell", response_model=QuickRunOut)
def agent_shell(payload: AgentShellIn):
    """
    שכבת נוחות מעל quick-run — מריץ פקודת Shell אחת ללא אישור.
    """
    return quick_run(QuickRunIn(
        title=payload.title or "agent-shell",
        actions=[ActionIn(type="shell", params={"cmd": payload.cmd})]
    ))
# ========= סוף Lucy Autopilot (MVP, Dynamic) =========
# <<< LUCY_AUTOPILOT_QUICK_RUN_END
